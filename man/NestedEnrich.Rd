% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_NestedEnrich.r
\name{NestedEnrich}
\alias{NestedEnrich}
\title{Nested Enrichment Analysis Class}
\description{
The \code{NestedEnrich} class automates the process of performing enrichment analysis
on nested data frames where each row represents a distinct set of conditions
under which gene lists are analyzed. This class is particularly useful for
complex experimental designs where gene data is segmented into multiple batches,
groups, or types, and where each segment might require separate enrichment analysis
against different annotation backgrounds.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-NestedEnrich-new}{\code{NestedEnrich$new()}}
\item \href{#method-NestedEnrich-set_batch_labels}{\code{NestedEnrich$set_batch_labels()}}
\item \href{#method-NestedEnrich-set_group_labels}{\code{NestedEnrich$set_group_labels()}}
\item \href{#method-NestedEnrich-get_results}{\code{NestedEnrich$get_results()}}
\item \href{#method-NestedEnrich-filter_and_get_results}{\code{NestedEnrich$filter_and_get_results()}}
\item \href{#method-NestedEnrich-unnest_and_get_results}{\code{NestedEnrich$unnest_and_get_results()}}
\item \href{#method-NestedEnrich-filter_and_set_significant_results}{\code{NestedEnrich$filter_and_set_significant_results()}}
\item \href{#method-NestedEnrich-get_significant_terms}{\code{NestedEnrich$get_significant_terms()}}
\item \href{#method-NestedEnrich-get_significant_results}{\code{NestedEnrich$get_significant_results()}}
\item \href{#method-NestedEnrich-build_and_set_i_matrix}{\code{NestedEnrich$build_and_set_i_matrix()}}
\item \href{#method-NestedEnrich-build_and_set_p_matrix}{\code{NestedEnrich$build_and_set_p_matrix()}}
\item \href{#method-NestedEnrich-get_i_matrix}{\code{NestedEnrich$get_i_matrix()}}
\item \href{#method-NestedEnrich-get_p_matrix}{\code{NestedEnrich$get_p_matrix()}}
\item \href{#method-NestedEnrich-build_and_set_hclust}{\code{NestedEnrich$build_and_set_hclust()}}
\item \href{#method-NestedEnrich-get_hclust}{\code{NestedEnrich$get_hclust()}}
\item \href{#method-NestedEnrich-get_clusters}{\code{NestedEnrich$get_clusters()}}
\item \href{#method-NestedEnrich-plot_hclust}{\code{NestedEnrich$plot_hclust()}}
\item \href{#method-NestedEnrich-cut_hclust_and_set_clusters}{\code{NestedEnrich$cut_hclust_and_set_clusters()}}
\item \href{#method-NestedEnrich-annotate_clusters_and_get_significant_results}{\code{NestedEnrich$annotate_clusters_and_get_significant_results()}}
\item \href{#method-NestedEnrich-is_using_pvclust}{\code{NestedEnrich$is_using_pvclust()}}
\item \href{#method-NestedEnrich-get_label_dict}{\code{NestedEnrich$get_label_dict()}}
\item \href{#method-NestedEnrich-prepare_results_for_plot}{\code{NestedEnrich$prepare_results_for_plot()}}
\item \href{#method-NestedEnrich-plot_with_pval}{\code{NestedEnrich$plot_with_pval()}}
\item \href{#method-NestedEnrich-plot_with_size}{\code{NestedEnrich$plot_with_size()}}
\item \href{#method-NestedEnrich-plot_combined}{\code{NestedEnrich$plot_combined()}}
\item \href{#method-NestedEnrich-count_gene_per_cluster}{\code{NestedEnrich$count_gene_per_cluster()}}
\item \href{#method-NestedEnrich-build_cluster_summary_table}{\code{NestedEnrich$build_cluster_summary_table()}}
\item \href{#method-NestedEnrich-write_xlsx}{\code{NestedEnrich$write_xlsx()}}
\item \href{#method-NestedEnrich-clone}{\code{NestedEnrich$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-new"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-new}{}}}
\subsection{Method \code{new()}}{
Initialize \code{NestedEnrich} object.

The constructor method for \code{NestedEnrich} sets up the enrichment analysis
environment by loading and preparing data. It handles the initialization
of data structures required for nested enrichment analysis based on
specified parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$new(
  nested_df,
  ann_space,
  batch_col = NULL,
  group_col = NULL,
  type_col = NULL,
  batch_labels = NULL,
  group_labels = NULL,
  data_col = "data",
  data_univ_col = NULL,
  data_nested_id = "uniprot",
  regex = "-.*",
  lim_pmin = 0.05,
  classic = FALSE,
  log_level = "WARN",
  hard_pmin_filter = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nested_df}}{A nested tibble containing gene sets organized by batch,
group, and type. Each row should correspond to a unique analysis context,
containing a nested dataframe of gene identifiers.
\itemize{
\item \code{batch}: First level of grouping, specifies the batch context of the gene list.
\item \code{group}: Second level of grouping, specifies the group context.
\item \code{type}: Third level of grouping, specifies the type context.
\item \code{data}: Column name containing the nested dataframe with gene identifiers;
must match the \code{data_col} argument.
\item \code{data_univ}: Optional; column name for the nested dataframe with the
"universe" of genes against which enrichment is assessed;
}}

\item{\code{ann_space}}{Annotation space data loaded from \code{load_ann_space}, defining
the annotation context for enrichment analysis.}

\item{\code{batch_col}}{Optional; specifies the column name for batch if different from 'batch'.}

\item{\code{group_col}}{Optional; specifies the column name for group if different from 'group'.}

\item{\code{type_col}}{Optional; specifies the column name for type.}

\item{\code{batch_labels}}{Optional; specifies labels for batches if renaming is required.}

\item{\code{group_labels}}{Optional; specifies labels for groups if renaming is required.}

\item{\code{data_col}}{Name of the column in \code{nested_df} containing gene data.}

\item{\code{data_univ_col}}{Optional; name of the column containing the universe of genes.}

\item{\code{data_nested_id}}{Column identifier in the nested data frames for gene identifiers.}

\item{\code{regex}}{Regular expression to clean gene identifiers (e.g., to remove version numbers).}

\item{\code{lim_pmin}}{Minimum p-value threshold; gene sets below this threshold are not retained
unless \code{hard_pmin_filter} is set to FALSE.}

\item{\code{classic}}{Boolean; if TRUE, performs analysis relative to the universe of genes.}

\item{\code{log_level}}{Logging level as defined by the logging package.}

\item{\code{hard_pmin_filter}}{Boolean; if TRUE, removes gene sets with p-values below \code{lim_pmin}.}

\item{\code{...}}{Additional arguments passed to the \code{enrich} function.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{NestedEnrich} object initialized with the provided data and settings.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-set_batch_labels"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-set_batch_labels}{}}}
\subsection{Method \code{set_batch_labels()}}{
set batch labels
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$set_batch_labels(batch_labels)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{batch_labels}}{batch_lables (named vector ordered)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-set_group_labels"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-set_group_labels}{}}}
\subsection{Method \code{set_group_labels()}}{
set group labels
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$set_group_labels(group_labels)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{group_labels}}{group_labels (named vector ordered)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_results}{}}}
\subsection{Method \code{get_results()}}{
Return results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_results(verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{verbose}}{Replace integer with IDs and add names for terms}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-filter_and_get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-filter_and_get_results}{}}}
\subsection{Method \code{filter_and_get_results()}}{
Return result table after filtering
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$filter_and_get_results(
  in_batch,
  in_group,
  in_type,
  in_ann_name,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{Vector of batch codes; used to select or report only gene lists
or enrichment results for specified batches.}

\item{\code{in_group}}{Vector of group codes; used to select or report only gene lists
or enrichment results for specified groups.}

\item{\code{in_type}}{Vector of type codes; used to select or report only gene lists
or enrichment results for specified types.}

\item{\code{in_ann_name}}{Vector of annotation name codes; used to select or report
only enrichment results for specified annotations.}

\item{\code{verbose}}{Replace integer with IDs and add names for terms}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-unnest_and_get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-unnest_and_get_results}{}}}
\subsection{Method \code{unnest_and_get_results()}}{
Return results unnested
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$unnest_and_get_results(verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{verbose}}{Replace integer with IDs and add names for terms}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Unnested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-filter_and_set_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-filter_and_set_significant_results}{}}}
\subsection{Method \code{filter_and_set_significant_results()}}{
filter results based on pvalue and set significant results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$filter_and_set_significant_results(
  p_max_enrich = 0.05,
  p_type = "qval_bh",
  build_and_set_i_matrix = TRUE,
  build_and_set_p_matrix = FALSE,
  build_and_set_hclust = TRUE,
  min_signif_term_for_clust = 10
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_max_enrich}}{max p-value to allow}

\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}

\item{\code{build_and_set_i_matrix}}{build a set term-gene incidence matrix}

\item{\code{build_and_set_p_matrix}}{build a set term-sample pvalue matrix}

\item{\code{build_and_set_hclust}}{built and set hclust with default parameters}

\item{\code{min_signif_term_for_clust}}{minimun number of term to start clusters}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_significant_terms"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_significant_terms}{}}}
\subsection{Method \code{get_significant_terms()}}{
Get the significant terms
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_significant_terms()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_significant_results}{}}}
\subsection{Method \code{get_significant_results()}}{
get significant results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_significant_results()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
tibble with significant results only
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_i_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_i_matrix}{}}}
\subsection{Method \code{build_and_set_i_matrix()}}{
Build and set the incidence matrix from the terms present in significant
results.

The raw annotation database is taken into account to build up this matrix
with the union of all universes as base.

This function requires the filter_and_set_significant_results method to
be ran before
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_i_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_p_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_p_matrix}{}}}
\subsection{Method \code{build_and_set_p_matrix()}}{
Build and set the pval matrix from the terms present in significant
results.

This function requires the filter_and_set_significant_results method to
be ran before
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_p_matrix(p_type = "pval")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_i_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_i_matrix}{}}}
\subsection{Method \code{get_i_matrix()}}{
get incidence matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_i_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_p_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_p_matrix}{}}}
\subsection{Method \code{get_p_matrix()}}{
get incidence matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_p_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_hclust}{}}}
\subsection{Method \code{build_and_set_hclust()}}{
Make hierarchical classification using pvclust.

IMPORTANT: Cluster ar automatically assigned to 8 clusters if not using
pvclust or using a p-value threshold of 0.8 in case of using pvclust.
Methods are available to modify these defaults.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_hclust(
  method_dist = "jaccard",
  method_hclust = "ward.D2",
  using_pvclust = FALSE,
  dim_reduce = 6,
  matrix_type = "incidence",
  prcomp_args = list(),
  pval_fun = log10,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method_dist}}{pvclust param preset (based on philentropy::distance
function)}

\item{\code{method_hclust}}{pvclust param preset}

\item{\code{using_pvclust}}{whether to use pvclust toi build the cluster}

\item{\code{dim_reduce}}{number of dimension to reduce the data (0 or False
means no reduction). If < 1, then the tol prcomp args will be used.
else if > 1 the rank. arg will be used to define the number of PCs to
keep.}

\item{\code{matrix_type}}{type of matrix to use for classification
\itemize{
\item "incidence" : Term gene incidence
\item "pval" : Term List p-value
\item "both" : both list concatenated
}}

\item{\code{prcomp_args}}{prcomp args that are passed if dim_reduce is not
0/False}

\item{\code{pval_fun}}{function to transform the p-values before clustering}

\item{\code{...}}{additional parameters for pvclust or hclust}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_hclust}{}}}
\subsection{Method \code{get_hclust()}}{
get hierarchical cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_hclust()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_clusters}{}}}
\subsection{Method \code{get_clusters()}}{
get clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_clusters()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_hclust}{}}}
\subsection{Method \code{plot_hclust()}}{
plot hierachical clustering of terms
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_hclust(
  cluster_rect = TRUE,
  rect_linetype = "solid",
  rect_linewidth = 1,
  ggdendro_args = list(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cluster_rect}}{Whether to add or not cluster rectangle}

\item{\code{rect_linetype}}{linetype for cluster rectangle}

\item{\code{rect_linewidth}}{size for cluster rectangle}

\item{\code{ggdendro_args}}{list of arguments passed to ggdendrogram}

\item{\code{...}}{passed to get_label_dict}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
graphical output from ggdendro::ggdendrogram
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-cut_hclust_and_set_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-cut_hclust_and_set_clusters}{}}}
\subsection{Method \code{cut_hclust_and_set_clusters()}}{
Cut hclust and set cluster
cut hclust return a named integer vector. Each term is linked with its
cluster id. Finally, the orphan terms are given an additional id.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$cut_hclust_and_set_clusters(
  value,
  min_size = 5,
  max_size = 8,
  max_size_only_to_parents = TRUE,
  min_size_only_to_children = TRUE,
  filter_max_size_first = TRUE,
  rm_redundancy_method = "largest",
  pvclust_pv = "au"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{value to cut the tree
\itemize{
\item p-values for pvclust (see pvclust::pvpick), default = 0.8
\item number of groups for hclust, default = 8
}}

\item{\code{min_size}}{for pvclust only, the minimum size of clusters}

\item{\code{max_size}}{for pvclust only, the minimum size of clusters}

\item{\code{max_size_only_to_parents}}{whether max_size should apply only to
cluster that are parent (include other clusters)}

\item{\code{min_size_only_to_children}}{whether min_size should apply only to
cluster that are child (are included by other clusters)}

\item{\code{filter_max_size_first}}{whether to filter based on max_size before
min_size. The order might have an impact on clusters kept.}

\item{\code{rm_redundancy_method}}{Method to remove the redundancy
\itemize{
\item "largest" : select the largest group for a term to be in only one
cluster
\item "smallest" : select the smallest group for a term to be in only one
cluster
}}

\item{\code{pvclust_pv}}{probability value (pv) for pvclust
(see pvclust::pvpick)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
named character as detailed in description
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-annotate_clusters_and_get_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-annotate_clusters_and_get_significant_results}{}}}
\subsection{Method \code{annotate_clusters_and_get_significant_results()}}{
annotate and get significant results with cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$annotate_clusters_and_get_significant_results()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-is_using_pvclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-is_using_pvclust}{}}}
\subsection{Method \code{is_using_pvclust()}}{
is the clustering built with pvclust
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$is_using_pvclust()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
boolean or NULL if no clustering
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_label_dict"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_label_dict}{}}}
\subsection{Method \code{get_label_dict()}}{
Prepare a translate dictionary with the different type of possible ids.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_label_dict(
  to = "reduced_label_with_code",
  append_cluster_id = FALSE,
  append_sep = "#",
  reduced_label_max_size = 40
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{to}}{type of label to use:
\itemize{
\item "id"
\item "reduced_label"
\item "reduced_label_with_code"
\item "reduced_label_with_id"
\item "full_name"
\item "empty"
}}

\item{\code{append_cluster_id}}{append clutser id to labels, default is false}

\item{\code{append_sep}}{separator between ids}

\item{\code{reduced_label_max_size}}{maximum length for term label
number of gene per term is used for ordering.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
translte diuctionary
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-prepare_results_for_plot"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-prepare_results_for_plot}{}}}
\subsection{Method \code{prepare_results_for_plot()}}{
prepare results for plot
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$prepare_results_for_plot(
  max_cluster = NULL,
  max_term_per_cluster = NULL,
  ordered_by_pval = TRUE,
  keep_only_signif = TRUE,
  in_batch = NULL,
  in_group = NULL,
  in_type = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{max_cluster}}{maximum number of cluster to plot (default is
no maximum)}

\item{\code{max_term_per_cluster}}{maximum number of term per cluster (default
is no maximum)}

\item{\code{ordered_by_pval}}{whether to order terms using p-value. If False the
number of gene per term is used for ordering.}

\item{\code{keep_only_signif}}{if False all enrichment will be kept if term is
significant in at least one place. In graph value not significant will
appears differently (cross in place of a cricle)}

\item{\code{in_batch}}{vector of batch code to keep}

\item{\code{in_group}}{vector of group code to keep}

\item{\code{in_type}}{vector of type code to keep}

\item{\code{...}}{passed to get_label_dict}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_with_pval"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_with_pval}{}}}
\subsection{Method \code{plot_with_pval()}}{
plot_enrich with pval
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_with_pval(p_type = "qval_bonferroni", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}

\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_with_size"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_with_size}{}}}
\subsection{Method \code{plot_with_size()}}{
plot_enrich with size
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_with_size(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_combined"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_combined}{}}}
\subsection{Method \code{plot_combined()}}{
Combination of enrichment plots with p-value per lists and term sizes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_combined(rel_widths = c(6, 1), ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rel_widths}}{relative width of the combined plots}

\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-count_gene_per_cluster"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-count_gene_per_cluster}{}}}
\subsection{Method \code{count_gene_per_cluster()}}{
count gene per cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$count_gene_per_cluster(
  id2name = NULL,
  new_name_label = "Gene Name",
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id2name}}{dictionary to translate gene ids}

\item{\code{new_name_label}}{name for the column of genes after translation}

\item{\code{verbose}}{replace column names with meaningful ones.
\itemize{
\item gene -> Gene
\item cluster -< Cluster
\item intra_x_term -> Intra
\item extra_x_term -> Extra
\item x_cluster -> Cluster
\item x_batch -> Batch
\item x_group -> Group
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
count table wih the following names:
\itemize{
\item gene: \link{character} gene
\item cluster: \link{integer} cluster (set of terms) identitified by its number
\item intra_x_term: \link{integer} Number of occurence for the gene in the terms
intra-cluster
\item extra_x_term: \link{integer} Number of occurence for the gene in the terms globally
\item x_cluster:  \link{integer} Number of occurence for the gene in clusters
\item x_batch: Number of occurence for the gene in batches
\item x_group: Number of occurence for the gene in groups
Build Cluster Summary Table
}

Constructs a summary table of the enrichment clusters.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_cluster_summary_table"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_cluster_summary_table}{}}}
\subsection{Method \code{build_cluster_summary_table()}}{
This method processes the results from previous enrichment analyses to compile
a detailed summary for each cluster. It focuses on aggregating minimum q-values
(adjusted p-values) for each cluster to assess the overall significance, alongside
other relevant term details.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_cluster_summary_table(verbose = FALSE, p_type = "qval_bh")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{verbose}}{Boolean, if TRUE, column names in the returned table are more descriptive.
The renaming adjusts column headers to be more human-readable and suitable for reports
or presentations. Specific changes include:
\itemize{
\item "cluster" becomes "Cluster"
\item "term" becomes "Term"
\item "name" becomes "Name"
\item "ann_name" becomes "Database"
\item "Ngenes" becomes "# of Genes"
\item "min_qval" becomes "Min q-value"
}}

\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A tibble table containing a summary of the clusters with the following columns:
\itemize{
\item \code{cluster}: Cluster identifier (numeric or character based on input data).
\item \code{term}: Unique identifier for each term within a cluster.
\item \code{name}: Descriptive name of the term.
\item \code{ann_name}: Source database from which the term was derived.
\item \code{Ngenes}: Count of genes associated with each term.
\item \code{min_qval}: Minimum q-value observed within each cluster, reflecting the lowest
adjusted p-value computed for terms within the cluster.
\item Additional columns representing each combination of batch, group, and type, formatted
as 'batch|group|type', each containing the q-value for the term within that context.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-write_xlsx"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-write_xlsx}{}}}
\subsection{Method \code{write_xlsx()}}{
write the enrichment data into xlsx files
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$write_xlsx(
  output_folder = ".",
  id2name = NULL,
  new_name_label = "Tested Gene Name",
  write_cluster_summary = TRUE,
  p_type = "qval_bh"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{output_folder}}{output folder (default is .)}

\item{\code{id2name}}{dictionary to translate gene ids}

\item{\code{new_name_label}}{name for the column of genes after translation}

\item{\code{write_cluster_summary}}{whether to write or not the summary
of all cluster}

\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-clone"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
