% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_NestedEnrich.r
\name{NestedEnrich}
\alias{NestedEnrich}
\title{Class representing a nested enrichment analysis}
\description{
An R6 class to represent nested enrichment. Enrichments are computed based on
a nested dataframe; each row is computed for each annotation source.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-NestedEnrich-new}{\code{NestedEnrich$new()}}
\item \href{#method-NestedEnrich-set_batch_labels}{\code{NestedEnrich$set_batch_labels()}}
\item \href{#method-NestedEnrich-set_group_labels}{\code{NestedEnrich$set_group_labels()}}
\item \href{#method-NestedEnrich-get_results}{\code{NestedEnrich$get_results()}}
\item \href{#method-NestedEnrich-filter_and_get_results}{\code{NestedEnrich$filter_and_get_results()}}
\item \href{#method-NestedEnrich-unnest_and_get_results}{\code{NestedEnrich$unnest_and_get_results()}}
\item \href{#method-NestedEnrich-filter_and_set_significant_results}{\code{NestedEnrich$filter_and_set_significant_results()}}
\item \href{#method-NestedEnrich-get_significant_terms}{\code{NestedEnrich$get_significant_terms()}}
\item \href{#method-NestedEnrich-get_significant_results}{\code{NestedEnrich$get_significant_results()}}
\item \href{#method-NestedEnrich-build_and_set_i_matrix}{\code{NestedEnrich$build_and_set_i_matrix()}}
\item \href{#method-NestedEnrich-build_and_set_p_matrix}{\code{NestedEnrich$build_and_set_p_matrix()}}
\item \href{#method-NestedEnrich-get_i_matrix}{\code{NestedEnrich$get_i_matrix()}}
\item \href{#method-NestedEnrich-get_p_matrix}{\code{NestedEnrich$get_p_matrix()}}
\item \href{#method-NestedEnrich-build_and_set_hclust}{\code{NestedEnrich$build_and_set_hclust()}}
\item \href{#method-NestedEnrich-get_hclust}{\code{NestedEnrich$get_hclust()}}
\item \href{#method-NestedEnrich-get_clusters}{\code{NestedEnrich$get_clusters()}}
\item \href{#method-NestedEnrich-plot_hclust}{\code{NestedEnrich$plot_hclust()}}
\item \href{#method-NestedEnrich-cut_hclust_and_set_clusters}{\code{NestedEnrich$cut_hclust_and_set_clusters()}}
\item \href{#method-NestedEnrich-annotate_clusters_and_get_significant_results}{\code{NestedEnrich$annotate_clusters_and_get_significant_results()}}
\item \href{#method-NestedEnrich-is_using_pvclust}{\code{NestedEnrich$is_using_pvclust()}}
\item \href{#method-NestedEnrich-get_label_dict}{\code{NestedEnrich$get_label_dict()}}
\item \href{#method-NestedEnrich-prepare_results_for_plot}{\code{NestedEnrich$prepare_results_for_plot()}}
\item \href{#method-NestedEnrich-plot_with_pval}{\code{NestedEnrich$plot_with_pval()}}
\item \href{#method-NestedEnrich-plot_with_size}{\code{NestedEnrich$plot_with_size()}}
\item \href{#method-NestedEnrich-plot_combined}{\code{NestedEnrich$plot_combined()}}
\item \href{#method-NestedEnrich-count_gene_per_cluster}{\code{NestedEnrich$count_gene_per_cluster()}}
\item \href{#method-NestedEnrich-build_cluster_summary_table}{\code{NestedEnrich$build_cluster_summary_table()}}
\item \href{#method-NestedEnrich-write_xlsx}{\code{NestedEnrich$write_xlsx()}}
\item \href{#method-NestedEnrich-clone}{\code{NestedEnrich$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-new"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-new}{}}}
\subsection{Method \code{new()}}{
Initialize \code{PairwiseDESeq2} object.

At initialization clustering is performed with default values and with
a number of cluster of 8. Please use the methods to adapt the clustering.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$new(
  nested_df,
  ann_space,
  batch_col = NULL,
  group_col = NULL,
  batch_labels = NULL,
  group_labels = NULL,
  data_col = "data",
  data_univ_col = NULL,
  data_nested_id = "uniprot",
  ncpus = 1,
  cluster_type = "PSOCK",
  regex = "-.*",
  lim_pmin = 0.05,
  classic = FALSE,
  log_level = "WARN",
  do_cluster_analysis = TRUE,
  hard_pmin_filter = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nested_df}}{nested tibble with gene set given in a tibble in
\code{data_col} variable and in \code{data_nested_id} nested variable}

\item{\code{ann_space}}{annotation space obtained with load_ann_space}

\item{\code{batch_col}}{batch column if not named batch}

\item{\code{group_col}}{group column if not named group}

\item{\code{batch_labels}}{batch labels}

\item{\code{group_labels}}{group labels}

\item{\code{data_col}}{see \code{nested_df}}

\item{\code{data_univ_col}}{same as \code{data_col} but for the "universe"}

\item{\code{data_nested_id}}{see \code{nested_df}}

\item{\code{ncpus}}{number of cpus}

\item{\code{cluster_type}}{see parallel package}

\item{\code{regex}}{regex to clean input data ids (for example to remove
versions ".1")}

\item{\code{lim_pmin}}{minimum pvalue acceptable. Below this gene set are not
kept if hard_pmin_filter is True, in any case gene set below this
threshold are used in multiple testing correction}

\item{\code{classic}}{Do analysis relative to the universe (vs parent-child)}

\item{\code{log_level}}{from logging package}

\item{\code{do_cluster_analysis}}{if false will skip auto_clustering}

\item{\code{hard_pmin_filter}}{if True, then gene set with a minimum p-value
attainable below this threshold will be removed.}

\item{\code{...}}{arguments passed to \code{enrich} function
If some ann codes are absent, all will be kept for absent database.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{NestedEnrich} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-set_batch_labels"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-set_batch_labels}{}}}
\subsection{Method \code{set_batch_labels()}}{
set batch labels
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$set_batch_labels(batch_labels)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{batch_labels}}{batch_lables (named vector ordered)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-set_group_labels"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-set_group_labels}{}}}
\subsection{Method \code{set_group_labels()}}{
set group labels
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$set_group_labels(group_labels)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{group_labels}}{group_labels (named vector ordered)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_results}{}}}
\subsection{Method \code{get_results()}}{
Return results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_results(verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{verbose}}{replace}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-filter_and_get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-filter_and_get_results}{}}}
\subsection{Method \code{filter_and_get_results()}}{
Return result table after filtering
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$filter_and_get_results(in_batch, in_group, in_type, in_ann_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{in_batch}}{vector of batch codes ; select or report only gene lists or
enrichment results for those batches}

\item{\code{in_group}}{vector of group codes ; select or report only gene lists or
enrichment results for those groups}

\item{\code{in_type}}{vector of type codes ; select or report only gene lists or
enrichment results for those types}

\item{\code{in_ann_name}}{vector of annotation name codes ; select or report only
enrichment results for those batch}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-unnest_and_get_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-unnest_and_get_results}{}}}
\subsection{Method \code{unnest_and_get_results()}}{
Return results unnested
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$unnest_and_get_results()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Unnested data frame with results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-filter_and_set_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-filter_and_set_significant_results}{}}}
\subsection{Method \code{filter_and_set_significant_results()}}{
filter results based on pvalue and set significant results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$filter_and_set_significant_results(
  p_max_enrich = 0.05,
  p_type = "qval_bh",
  build_and_set_i_matrix = TRUE,
  build_and_set_p_matrix = FALSE,
  build_and_set_hclust = TRUE,
  min_signif_term_for_clust = 10
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_max_enrich}}{max p-value to allow}

\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}

\item{\code{build_and_set_i_matrix}}{build a set term-gene incidence matrix}

\item{\code{build_and_set_p_matrix}}{build a set term-sample pvalue matrix}

\item{\code{build_and_set_hclust}}{built and set hclust with default parameters}

\item{\code{min_signif_term_for_clust}}{minimun number of term to start clusters}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_significant_terms"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_significant_terms}{}}}
\subsection{Method \code{get_significant_terms()}}{
Get the significant terms
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_significant_terms()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_significant_results}{}}}
\subsection{Method \code{get_significant_results()}}{
get significant results
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_significant_results()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
tibble with significant results only
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_i_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_i_matrix}{}}}
\subsection{Method \code{build_and_set_i_matrix()}}{
Build and set the incidence matrix from the terms present in significant
results.

The raw annotation database is taken into account to build up this matrix
with the union of all universes as base.

This function requires the filter_and_set_significant_results method to
be ran before
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_i_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_p_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_p_matrix}{}}}
\subsection{Method \code{build_and_set_p_matrix()}}{
Build and set the pval matrix from the terms present in significant
results.

This function requires the filter_and_set_significant_results method to
be ran before
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_p_matrix(p_type = "pval")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_type}}{type of pvalue to use:
\itemize{
\item "pval" : raw p-value
\item "qval_bh" : q-value using Benjamini Hochberg
\item "qval_bonferroni": q-value using Bonferoni
}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_i_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_i_matrix}{}}}
\subsection{Method \code{get_i_matrix()}}{
get incidence matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_i_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_p_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_p_matrix}{}}}
\subsection{Method \code{get_p_matrix()}}{
get incidence matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_p_matrix()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_and_set_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_and_set_hclust}{}}}
\subsection{Method \code{build_and_set_hclust()}}{
Make hierarchical classification using pvclust.

IMPORTANT: Cluster ar automatically assigned to 8 clusters if not using
pvclust or using a p-value threshold of 0.8 in case of using pvclust.
Methods are available to modify these defaults.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_and_set_hclust(
  method_dist = "cosine",
  method_hclust = "ward.D2",
  using_pvclust = FALSE,
  dim_reduce = 6,
  matrix_type = "incidence",
  prcomp_args = list(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method_dist}}{pvclust param preset (based on philentropy::distance
function)}

\item{\code{method_hclust}}{pvclust param preset}

\item{\code{using_pvclust}}{whether to use pvclust toi build the cluster}

\item{\code{dim_reduce}}{number of dimension to reduce the data (0 or False
means no reduction). If < 1, then the tol prcomp args will be used.
else if > 1 the rank. arg will be used to define the number of PCs to
keep.}

\item{\code{matrix_type}}{type of matrix to use for classification
\itemize{
\item "incidence" : Term gene incidence
\item "pval" : Term List p-value
\item "both" : both list concatenated
}}

\item{\code{prcomp_args}}{prcomp args that are passed if dim_reduce is not
0/False}

\item{\code{...}}{additional parameters for pvclust or hclust}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_hclust}{}}}
\subsection{Method \code{get_hclust()}}{
get hierarchical cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_hclust()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_clusters}{}}}
\subsection{Method \code{get_clusters()}}{
get clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_clusters()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_hclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_hclust}{}}}
\subsection{Method \code{plot_hclust()}}{
plot hierachical clustering of terms
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_hclust(
  cluster_rect = TRUE,
  rect_linetype = "solid",
  rect_linewidth = 1,
  ggdendro_args = list(),
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cluster_rect}}{Whether to add or not cluster rectangle}

\item{\code{rect_linetype}}{linetype for cluster rectangle}

\item{\code{rect_linewidth}}{size for cluster rectangle}

\item{\code{ggdendro_args}}{list of arguments passed to ggdendrogram}

\item{\code{...}}{passed to get_label_dict}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
graphical output from ggdendro::ggdendrogram
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-cut_hclust_and_set_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-cut_hclust_and_set_clusters}{}}}
\subsection{Method \code{cut_hclust_and_set_clusters()}}{
Cut hclust and set cluster
cut hclust return a named integer vector. Each term is linked with its
cluster id. Finally, the orphan terms are given an additional id.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$cut_hclust_and_set_clusters(
  value,
  min_size = 5,
  max_size = 8,
  max_size_only_to_parents = TRUE,
  min_size_only_to_children = TRUE,
  filter_max_size_first = TRUE,
  rm_redundancy_method = "largest",
  pvclust_pv = "au"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{value}}{value to cut the tree
\itemize{
\item p-values for pvclust (see pvclust::pvpick)
\item number of groups for hclust
}}

\item{\code{min_size}}{for pvclust only, the minimum size of clusters}

\item{\code{max_size}}{for pvclust only, the minimum size of clusters}

\item{\code{max_size_only_to_parents}}{whether max_size should apply only to
cluster that are parent (include other clusters)}

\item{\code{min_size_only_to_children}}{whether min_size should apply only to
cluster that are child (are included by other clusters)}

\item{\code{filter_max_size_first}}{whether to filter based on max_size before
min_size. The order might have an impact on clusters kept.}

\item{\code{rm_redundancy_method}}{Method
\itemize{
\item "largest" : select the largest group for a term to be in only one
cluster
\item "smallest" : select the smallest group for a term to be in only one
cluster
}}

\item{\code{pvclust_pv}}{probability value (pv) for pvclust
(see pvclust::pvpick)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
named character as detailed in description
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-annotate_clusters_and_get_significant_results"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-annotate_clusters_and_get_significant_results}{}}}
\subsection{Method \code{annotate_clusters_and_get_significant_results()}}{
annotate and get significant results with cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$annotate_clusters_and_get_significant_results()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-is_using_pvclust"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-is_using_pvclust}{}}}
\subsection{Method \code{is_using_pvclust()}}{
is the clustering built with pvclust
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$is_using_pvclust()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
boolean or NULL if no clustering
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-get_label_dict"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-get_label_dict}{}}}
\subsection{Method \code{get_label_dict()}}{
Prepare a translate dictionary with the different type of possible ids.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$get_label_dict(
  to = "reduced_label_with_code",
  append_cluster_id = FALSE,
  append_sep = "#",
  reduced_label_max_size = 40
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{to}}{type of label to use:
\itemize{
\item "id"
\item "reduced_label"
\item "reduced_label_with_code"
\item "reduced_label_with_id"
\item "full_name"
\item "empty"
}}

\item{\code{append_cluster_id}}{append clutser id to labels, default is false}

\item{\code{append_sep}}{separator between ids}

\item{\code{reduced_label_max_size}}{maximum length for term label
number of gene per term is used for ordering.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
translte diuctionary
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-prepare_results_for_plot"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-prepare_results_for_plot}{}}}
\subsection{Method \code{prepare_results_for_plot()}}{
prepare results for plot
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$prepare_results_for_plot(
  max_cluster = NULL,
  max_term_per_cluster = NULL,
  ordered_by_pval = TRUE,
  keep_only_signif = TRUE,
  in_batch = NULL,
  in_group = NULL,
  in_type = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{max_cluster}}{maximum number of cluster to plot (default is
no maximum)}

\item{\code{max_term_per_cluster}}{maximum number of term per cluster (default
is no maximum)}

\item{\code{ordered_by_pval}}{whether to order terms using p-value. If False the
number of gene per term is used for ordering.}

\item{\code{keep_only_signif}}{if False all enrichment will be kept if term is
significant in at least one place. In graph value not significant will
appears differently (cross in place of a cricle)}

\item{\code{in_batch}}{vector of batch code to keep}

\item{\code{in_group}}{vector of group code to keep}

\item{\code{in_type}}{vector of type code to keep}

\item{\code{...}}{passed to get_label_dict}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_with_pval"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_with_pval}{}}}
\subsection{Method \code{plot_with_pval()}}{
plot_enrich with pval
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_with_pval(p_type = "qval_bonferroni", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p_type}}{p-value type code to use e.g p_val}

\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_with_size"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_with_size}{}}}
\subsection{Method \code{plot_with_size()}}{
plot_enrich with size
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_with_size(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-plot_combined"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-plot_combined}{}}}
\subsection{Method \code{plot_combined()}}{
Combination of enrichment plots with p-value per lists and term sizes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$plot_combined(rel_widths = c(6, 1), ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rel_widths}}{relative width of the combined plots}

\item{\code{...}}{arguments passed to \code{prepare_results_for_plot}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-count_gene_per_cluster"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-count_gene_per_cluster}{}}}
\subsection{Method \code{count_gene_per_cluster()}}{
count gene per cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$count_gene_per_cluster(
  id2name = NULL,
  new_name_label = "Gene Name",
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id2name}}{dictionary to translate gene ids}

\item{\code{new_name_label}}{name for the column of genes after translation}

\item{\code{verbose}}{replace column names with meaningful ones.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
count table
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-build_cluster_summary_table"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-build_cluster_summary_table}{}}}
\subsection{Method \code{build_cluster_summary_table()}}{
Build cluster summary table. A cluster summary with all information about
functional terms within.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$build_cluster_summary_table()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
a tibble table
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-write_xlsx"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-write_xlsx}{}}}
\subsection{Method \code{write_xlsx()}}{
write the enrichment data into xlsx files
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$write_xlsx(
  output_folder = ".",
  id2name = NULL,
  new_name_label = "Tested Gene Name",
  write_cluster_summary = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{output_folder}}{output folder (default is .)}

\item{\code{id2name}}{dictionary to translate gene ids}

\item{\code{new_name_label}}{name for the column of genes after translation}

\item{\code{write_cluster_summary}}{whether to write or not the summary
of all cluster}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-NestedEnrich-clone"></a>}}
\if{latex}{\out{\hypertarget{method-NestedEnrich-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NestedEnrich$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
