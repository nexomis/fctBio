#' @include utils.r

NULL

#' Query Expression Tags for Gene Selection#'
#'
#' @description
#' `query_genes` allows for dynamic querying of a nested tibble containing gene
#' sets and enrichment data. This function can filter genes based on various
#' attributes such as batch presence, group membership, cluster occurrence, or
#' specific terms within an enrichment analysis. t is typically used
#' to extract specific subsets of genes from results generated by the `NestedEnrich`
#' class, particularly useful for further analysis or visualization.
#'
#' @param nested_df A nested tibble as returned by the `get_results` method of the
#' `NestedEnrich` class, with `verbose = TRUE` to ensure descriptive column
#' names which facilitate easier querying.
#' @param filter_name A character string specifying the attribute to filter on. 
#' Supported filters include:
#'   - `batch`: Select genes present in specified batch(es).
#'   - `batch_label`: Select genes based on batch label(s).
#'   - `group`: Select genes present in specified group(s).
#'   - `group_label`: Select genes based on group label(s).
#'   - `type`: Select genes present in specified type(s).
#'   - `term_id`: Select genes associated with a specific term ID(s).
#'   - `term_name`: Select genes associated with a specific term name(s).
#'   - `cluster`: Select genes associated with a specific cluster(s).
#'   - `intra_occurences`: Select genes based on their minimal occurrences within the same term.
#'   - `extra_occurences`: Select genes based on their minimal occurrences across all terms.
#'   - `cluster_occurences`: Select genes based on their minimal occurrences within specified clusters.
#' @param value The value(s) to filter by, corresponding to the `filter_name`. 
#' This can be a single value or a vector of values depending on the filter context.
#' @param genes_per_clusters Optional but required for xxx_occurrences filters
#' a data frame from the `count_gene_per_cluster`#' method in the `NestedEnrich` 
#' class, which includes gene occurrence data across clusters.
#' @param batch_labels Optional; a vector of batch labels if `batch_label` filter is used.
#' This helps map user-friendly labels to batch identifiers in the dataset.
#' @param group_labels Optional; a vector of group labels if `group_label` filter is used.
#' This helps map user-friendly labels to group identifiers in the dataset.
#'
#' @return A character vector with gene IDs
#'
#' @export
#' @examples
#' # Assuming `nested_df` is a dataset obtained from NestedEnrich with verbose = TRUE
#' genes_in_batch1 <- query_genes(nested_df, filter_name = "batch", value = "batch1")
#' genes_in_termGO <- query_genes(nested_df, filter_name = "term_id", value = "GO:XXXXXX")
#' genes_by_occurrence <- query_genes(nested_df, filter_name = "cluster_occurences",
#'                                    value = 5, genes_per_clusters = genes_cluster_data)
query_genes <- function(nested_df, filter_name, value,
  genes_per_clusters = NULL,
  batch_labels = NULL, group_labels = NULL
) {

  if (! all(value %in% query_genes_choices(nested_df, filter_name,
  genes_per_clusters, batch_labels, group_labels))) {
    warning("value not a valid choice")
  }

  if (filter_name == "batch_label" && is.null(batch_labels)) {
    warning("filtering batch_label without label dict")
    batch_labels <- query_genes_choices(nested_df, filter_name)
    names(batch_labels) <- batch_labels
  }

  if (filter_name == "group_label" && is.null(group_labels)) {
    warning("filtering group_label without label dict")
    group_labels <- query_genes_choices(nested_df, filter_name)
    names(group_labels) <- group_labels
  }

  switch(filter_name,
    batch = {
      unique(unlist(
        nested_df[batch %in% value][["gene_inputs"]]
      ))
    },
    batch_label = {
      unique(unlist(
        nested_df[batch_labels[as.character(batch)] %in% value][["gene_inputs"]]
      ))
    },
    group = {
      unique(unlist(
        nested_df[group %in% value][["gene_inputs"]]
      ))
    },
    group_label = {
      unique(unlist(
        nested_df[group_labels[as.character(group)] %in% value][["gene_inputs"]]
      ))
    },
    type = {
      nested_df[type %in% value][["gene_inputs"]]
    },
    term_id = {
      unique(unlist(purrr::map(
        nested_df[["enrich"]],
        function(df) {
          unique(unlist(
            df[term %in% value][["genes"]]
          ))
        }
      )))
    },
    term_name = {
      unique(unlist(purrr::map(
        nested_df[["enrich"]],
        function(df) {
          unique(unlist(
            df[name %in% value][["genes"]]
          ))
        }
      )))
    },
    cluster = {
      if (is.null(genes_per_clusters)) {
        choices <- character()
      } else {
        choices <- unique(
          genes_per_clusters[
            as.integer(cluster) %in% as.integer(value)][["gene"]])
      }
      choices
    },
    intra_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- unique(
          genes_per_clusters[intra_x_term >= value][["gene"]])
      }
      choices
    },
    extra_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- unique(
          genes_per_clusters[extra_x_term >= value][["gene"]])
      }
      choices
    },
    cluster_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- unique(
          genes_per_clusters[x_cluster >= value][["gene"]])
      }
      choices
    }
  )
}

#' Retrieve Possible Choices for Gene Querying
#'
#' @description
#'
#' This function provides potential filtering options for querying genes based on
#' the specified filter criteria. It is designed to assist users in making selections
#' when using the `query_genes` function by listing available options within the dataset.
#'
#' `query_genes_choices` extracts unique values from the specified filter attribute
#' within the provided dataset. These values can then be used to define filters
#' in calls to the `query_genes` function, ensuring that users are selecting from
#' valid and existing data categories.
#'
#' @inheritParams query_genes
#'
#' @return A vector of unique values corresponding to the specified `filter_name`,
#' which can be used as inputs for filtering in the `query_genes` function.
#'
#' @export
#' @examples
#' # Assuming `nested_df` is a dataset obtained from NestedEnrich with verbose = TRUE
#' batch_options <- query_genes_choices(nested_df, "batch")
#' term_options <- query_genes_choices(nested_df, "term_id")
#' group_options <- query_genes_choices(nested_df, "group")
#' @export
query_genes_choices <- function(nested_df, filter_name,
  genes_per_clusters = NULL,
  batch_labels = NULL, group_labels = NULL
) {
  switch(filter_name,
    batch = {
      unique(nested_df$batch)
    },
    batch_label = {
      if (is.null(batch_labels)) {
        choices <- unique(nested_df$batch)
      } else {
        choices <- batch_labels[as.character(unique(nested_df$batch))]
      }
      choices
    },
    group = {
      unique(nested_df$group)
    },
    group_label = {
      if (is.null(group_labels)) {
        choices <- unique(nested_df$group)
      } else {
        choices <- group_labels[as.character(unique(nested_df$group))]
      }
      choices
    },
    type = {
      unique(nested_df$type)
    },
    term_id = {
      sort(unique(unlist(purrr::map(
        nested_df$enrich,
        function(df) {
          df[["term"]]
        }
      ))))
    },
    term_name = {
      sort(unique(unlist(purrr::map(
        nested_df$enrich,
        function(df) {
          df$name
        }
      ))))
    },
    cluster = {
      if (is.null(genes_per_clusters)) {
        choices <- character()
      } else {
        choices <- unique(genes_per_clusters[["cluster"]])
      }
      choices
    },
    intra_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- seq(0,max(genes_per_clusters[["intra_x_term"]]))
      }
      choices
    },
    extra_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- seq(0, max(genes_per_clusters[["extra_x_term"]]))
      }
      choices
    },
    cluster_occurences = {
      if (is.null(genes_per_clusters)) {
        choices <- integer()
      } else {
        choices <- seq(0, max(genes_per_clusters[["x_cluster"]]))
      }
      choices
    }
  )
}
